# 7주차 공부내용 정리
## State

State는 JavaScript 객체이고 React에서 React 컴포넌트의 상태를 의미합니다. 또한, 컴포넌트의 상태가 정상인지 비정상인지 구별하는 것보다는 리액트 컴포넌트의 데이터라는 의미에 더 가까운 개념입니다.

이 개념들을 간단하게 정리하면 

“리액트 컴포넌트의 변경 가능한 데이터” = “State”

State는 사전에 미리 정해진 것이 아니라 React 컴포넌트를 개발하는 개발자가 정의해서 사용하게 되며 State를 정의할 때 중요한 점은 렌더링이나 데이터 흐름에 사용되는 값만 state에 포함시켜야 합니다. 

→ State가 변경될 경우 컴포넌트가 재렌더링되는 데 렌더링과 데이터 흐름에 관련 없는 값을 포함하게 되면 불필요한 경우에 컴포넌트가 재렌더링하여 성능을 저하시킬 수 있기 때문입니다.

이러한 과정이 발생하지 않도록 렌더링과 데이터 흐름에 관련있는 값만 state에 포함하도록 해야하며 그렇지 않은 값은 인스턴스 필드에 저장하면 됩니다.

``` java

class LikeButton extends React.Component {
constructor(props) {
super(props);

this.state = {
linked: false
};
}
}
```
위 코드에서 this.state 부분이 현재 LikeButton이라는 React class 컴포넌트의 state를 저장하는 부분입니다.  여기서, Class 컴포넌트의 경우 State를 생성자에서 정의합니다. 이렇게 정의된 State는 정의된 이후 일반적인 JavaScript 변수를 다루듯이 직접 수정할 수 없습니다.

```java

//state를 직접 수정(잘못된 방법)
this.state - {
name = 'Inje'
};

//setState 함수를 통한 수정 (정상적인 방법)
this.setState({
name: 'Inje'
});

```
→ 위처럼 직접 수정하게 되면 개발자가 의도한 대로 작동하지 않을 가능성이 존재하고 제약을 통해 더 안정적이고 예측 가능한 애플리케이션 개발을 할 수 있다고 합니다.

→ setState 함수를 사용하면 

+ React의 변화 감지 메커니즘 활성화
+ 효율적인 상태 업데이트 일괄 처리
+ 안전한 비동기 상태 업데이트 처리
+ 성능 최적화를 위한 기능 제공

이러한 이유로 클래스 컴포넌트에서 stste를 변경하고자 할 때는 두번째 코드처럼 꼭 setState라는 함수를 사용해야합니다.

---

### Lifecycle

Lifecycle은 React Component가 가지고 있는 생명주기로 컴포넌트가 생성되는 시점과 사라지는 시점이 정해져있다는 의미입니다.

![Lifecycle 출생인생사망](https://github.com/yeab-in/Code-Techeer/blob/main/ch06-1.png)

(React class 컴포넌트의 생명주기를 나타낸 그림)

출생, 인생, 사망으로 인생이 나누어져있고 각 과정의 하단에 초록색으로 표시된 부분은 생명주기에 따라 호출되는 클래스 컴포넌트의 함수입니다 이 초록색 함수들을 생명주기 함수로 Lifecycle 매소드라고 부른다고 합니다.

### 출생단계

마운트 = 컴포넌트가 생성되는 시점

생성자가 실행되는 데 생성자에서는 컴포넌트의 State를 정의하고 컴포넌트가 렌더링되며 이후에 컴포넌트 디드 마운트 함수가 호출됩니다

### 인생단계

사람이 삶을 살아가는 동안 변화를 겪으며 성장하는 것처럼 컴포넌트도 여러번 렌더링하는 과정이 있습니다. 이를 업데이트 되는 과정이라고 합니다. 업데이트 과정에서는 props가 변경되거나 setState 함수 호출에 의해 state가 변경되거나 강제 업데이트 함수 호출로 인해 컴포넌트가 다시 렌더링 되어 함수를 호출하는 것으로 볼 수 있습니다

### 사망단계

리액트 컴포넌트가 사라지는 과정 = Unmount

상위 컴포넌트에서 현재 컴포넌트를 더 이상 화면에 표시하지 않게 될 때 Unmount과정이 진행됩니다. ⇒ Comonent는 계속 존재하는 것이 아니라 시간의 흐름에 따라 생성되고 업데이트되다가 사라집니다.

## (실습) State 사용해보기

Notification.jsx

```java
import React from "react";

const styles = {
    wrapper: {
        margin: 9, //단어 위아래 공백
        padding: 9,
        display: "flex",
        flexDirection: "row",
        border: "1px solid grey",
        borderRadius: 15,
    },
    messageText: {
        color: "Black",
        fontSize: 15,
    },
};

class Notification extends React.Component {
   constructor(props) {
    super(props);

    this.state={};
   }


render() {
    return (
       
            <div style={styles.wrapper}>
            <span style = {styles.messageText}>{this.props.message}</span>
            </div>
    );
}
}
export default Notification;


```

NotificaitonList.jsx

```java
import React from "react";
import Notification from "./Notification"

const reservedNotifications = [
    {
        message: "안녕하세요, 오늘 일정을 알려드립니다.",

    },
    {
        message: "점심식사 시간입니다.",

    },
    {
        message: "이제 곧 미팅이 시작됩니다.",

    },
];

var timer;

class NotificationList extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            notifications: [],
        };
    }

    componentDidMount() {
        const {notifications} = this.state;
        timer = setInterval(()=> {
            if (notifications.length < reservedNotifications.length) {
                const index =  notifications.length;
                notifications.push(reservedNotifications[index]);
                this.setState({
                    notifications: notifications,
                });
            } else {
                clearInterval(timer);
            }
        }, 1000);
    }


render() {
    return (
        <div>
            {this.state.notifications.map((notification)=> {
                return <Notification message={notification.message} />;
            })}
        </div>
    );
}
}

export default NotificationList;
```
실행결과
![실행결과](https://github.com/yeab-in/Code-Techeer/blob/main/ch06-2.png)
