## Event

이벤트란 특정 사건을 의미함.

예) 사용자가 버튼을 클릭한 사건 = 버튼 클릭 이벤트

이때 이벤트를 처리하는 것 = 이벤트를 핸들링한다

## DOM과 리액트의 이벤트 비교

DOM에서는 클릭 이벤트를 처리할 함수를 onclick이라는 함수를 통해 전달함

DOM은 문자열로 함수를 전달하지만 리액트에서는 함수 그대로 전달함.

## Event Handler

어떤 사건이 발생하면 사건을 처리하는 역할.

이벤트를 발생하는 것을 계쏙 듣고 있다는 의미로 

Event Listner이라고도 불림

## Argument 전달

Argument=Event Handler에 전달할 데이터

이벤트헨들러에 파라미터를 전달을 두가지 방법으로 볼 수 있음

첫 번째: arrow function 사용
```javja
<button onClick={(event) => this.deletItem(id, event)}> 삭제하기 </button>

```

두 번째: bind 사용
```java
<button onClick={this.deletItem.bind(this, id)}> 삭제하기 </button>
```
두 방법 모두 첫번째 파라미터는 id이고 두번째 파라미터는 이벤트가 전달됨

첫번째 arrow function을 사용한 방법은 이벤트를 두번째 파라미터로 넣어주었고 두번째 bind를 사욯한 방법은 이벤트가 자동으로 id이후에 두번째 파라미터로 전달됨

## Conditional Rendering

 = 조건에 따른 렌더링

(즉, 어떤 조건에 따라서 렌더링이 달라지는 것)

조건문의 결과는 True 아니면 False가 나오는 데 이 결과에 따라서 렌더링을 다르게 하는 것을 조건부 렌더링이라고  함


## Inline If

If문의 경우 && 연산자 사용⇒ 양쪽의 조건문이 true여야지 true 값이 나옴

그래서 true이면 오른쪽에 나오는 element가 결과값이 되고 false면 false가 결과값이 됨

## Inline If Else

?연산자를 사용

condition? true : false

예) {props.isLoggedIn? ‘로그인’ : ‘로그인하지 않은’}

true ⇒ 로그인 (출력)

false ⇒ 로그인하지 않은 (출력)

## Lists and Key

List ⇒ 같은 아이템을 순서대로 모아 놓은 것

Array ⇒ 자바스크립트의 변수나 객체들을 하나의 변수로 묶어 놓은 것

Key ⇒ 각 객체나 아이템을 구분할 수 있는 고유한 값

map() 

⇒ 배열에 들어있는 각 변수에 어떤 처리를 한 뒤 리턴하는 것 (즉, 배열의 첫 번째 아이템부터 순서대로 각 아이템의 어떠한 연산을 수행한 뒤에 최종결과를 배열로 만들어서 리턴)

⇒ 이 함수 안에 있는 엘리먼트는 꼭 Key 가 필요함

## KEY

고유하다 = 범위 한정

같은 리스트에 있는 엘리먼트 사이에서만 고유한 값이면 됨.

## Form

⇒ 텍스트를 입력하는 양식뿐만 아니라 체크박스나 셀렉트 등 사용자가 무언사를 선택해야하는 모든 것

⇒ 사용자로부터 입력을 받기 위해 사용됨

## Controlled Components

⇒ 값이 리액트의 통제를 받는 엘리먼트, 사용자의 입력을 직접적으로 제어할 수 있음
![image9-1](https://github.com/yeab-in/Code-Techeer/blob/main/9-1.png)
여러가지 종류의 폼

- Textarea 태그

여러줄에 걸쳐 긴 텍스트를 입력받기 위한 HTML 태그

텍스트를 태그가 감싸는 형태로 작성

- Select  태그

Drop-down 목록을 보여주기 위한 HTML 태그

Drop-down 목록은 여러가지 옵션 중 하나를 선택할 수 있는 기능 제공

옵션 태그를 select 태그가 감싸는 형태로 작성

- File Input 태그 → 리액트의 통제를 받지 않음

디바이스의 저장 장치로부터 하나 또는 여러개의 파일을 선택할 수 있게 해주는 HTML 태그

State에 있는 여러 개의 데이터를 여러 개의 하위 컴포넌트에서 공통적으로 사용하는 경우
![image9-2](https://github.com/yeab-in/Code-Techeer/blob/main/9-2.png)
하위 컴포넌트가 공통된 부모 컴포넌트의 state를 공유하여 사용하는 것.

Composition = 여러개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 것 (구성보다는 합성이라는 의미에 가까움)

-> 어떻게 여러개의 컴포넌트들을 조합할 것 인가?

- Containment

⇒ 하위 컴포넌트를 포함하는 형태의 합성 방법

- Specialization

범용적으로 쓸 수 있는 컴포넌트를 만들어 놓고 이를 특수화 시켜서 컴포넌트를 사욯하는 방법

- Inheritance

다른 컴포넌트로부터 상속받아서 새로운 컴포넌트를 만드는 것

컴포지션 결론

복잡한 컴포넌트를 쪼개서 여러 개의 컴포넌트로 만들고, 만든 컴포넌트들을 조합해서 새로운 컴포넌트를 만드는 것이 좋음

Context

컴포넌트의 Props를 통해 데이터 전달하는 방법 대신 컴포넌트 트리를 통해 곧바로 컴포넌트로 전달하는 새로운 방식→ 쉽게 컴포넌트에 접근 가능

사용시 고려할 점

컴포넌트와 컨텍스트가 연동되면 재사용성이 떨어짐

그래서, 다른 레벨의 많은 컴포넌트가 데이터를 필요로 하는 경우가 아니라면 기존에 사용하던 방식대로 props를 통해 데이터를 전달하는 컴포넌트 컴포지션 방법이 더 적합할 수 있음

Context API

컨텍스트 생성(밑 코드)
```java
React.createContext(기본값)
```
함수의 값을 기본값에 넣어주면 컨텍스트 객체가 만들어짐

리액트에서 렌더링이 일어날 때 컨테스트 객체를 구독하는 하위 컴포넌트가 나오면  현재 컨텍스트의 값을 가장 가까이에 있는 상위 레벨의 프로바이더로부터 받아오게 됨

BUT, 만약 상위레벨에 매칭되는 프로바이더가 없다면?

⇒ 이러한 경우에만 기본값이 사용됨

```java
Context.Provider
```
Provider 컴포넌트로 하위 컴포넌트들을 감싸주면 모든 하위 컴포넌트들이 해당 컨텍스트의 데이터에 접근할 수 있게 됨.
